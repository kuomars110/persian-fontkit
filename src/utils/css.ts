/**
 * CSS generation utilities for optimized fonts
 */

export interface FontFaceOptions {
  fontFamily: string;
  fontPath: string;
  fontWeight?: number | string;
  fontStyle?: "normal" | "italic";
  fontDisplay?: "auto" | "block" | "swap" | "fallback" | "optional";
  unicodeRange?: string;
}

export interface PreloadOptions {
  fontPath: string;
  type?: "font/woff2" | "font/woff" | "font/ttf";
  crossOrigin?: "anonymous" | "use-credentials";
}

/**
 * Generate @font-face CSS rule
 */
export function generateFontFace(options: FontFaceOptions): string {
  const {
    fontFamily,
    fontPath,
    fontWeight = 400,
    fontStyle = "normal",
    fontDisplay = "swap",
    unicodeRange,
  } = options;

  let css = `@font-face {\n`;
  css += `  font-family: '${fontFamily}';\n`;
  css += `  src: url('${fontPath}') format('woff2');\n`;
  css += `  font-weight: ${fontWeight};\n`;
  css += `  font-style: ${fontStyle};\n`;
  css += `  font-display: ${fontDisplay};\n`;

  if (unicodeRange) {
    css += `  unicode-range: ${unicodeRange};\n`;
  }

  css += `}\n`;

  return css;
}

/**
 * Generate multiple @font-face rules
 */
export function generateFontFaces(fonts: FontFaceOptions[]): string {
  return fonts.map((font) => generateFontFace(font)).join("\n");
}

/**
 * Generate preload link tag
 */
export function generatePreloadTag(options: PreloadOptions): string {
  const { fontPath, type = "font/woff2", crossOrigin = "anonymous" } = options;

  return `<link rel="preload" href="${fontPath}" as="font" type="${type}" crossorigin="${crossOrigin}">`;
}

/**
 * Generate multiple preload tags
 */
export function generatePreloadTags(fonts: PreloadOptions[]): string {
  return fonts.map((font) => generatePreloadTag(font)).join("\n");
}

/**
 * Generate complete CSS file with font faces
 */
export function generateCSSFile(
  fonts: FontFaceOptions[],
  comments: string[] = []
): string {
  let css = "/**\n";
  css += " * Optimized Persian Font Faces\n";
  css += " * Generated by persian-fontkit\n";
  if (comments.length > 0) {
    css += " *\n";
    comments.forEach((comment) => {
      css += ` * ${comment}\n`;
    });
  }
  css += " */\n\n";

  css += generateFontFaces(fonts);

  return css;
}

/**
 * Generate CSS variables for font families
 */
export function generateCSSVariables(fontFamilies: string[]): string {
  let css = ":root {\n";

  fontFamilies.forEach((family) => {
    const varName = family.toLowerCase().replace(/\s+/g, "-");
    css += `  --font-${varName}: '${family}', sans-serif;\n`;
  });

  css += "}\n";

  return css;
}

/**
 * Get font format from file extension
 */
export function getFontFormat(extension: string): string {
  const formats: Record<string, string> = {
    ".woff2": "woff2",
    ".woff": "woff",
    ".ttf": "truetype",
    ".otf": "opentype",
  };

  return formats[extension.toLowerCase()] || "woff2";
}

/**
 * Get MIME type from extension
 */
export function getFontMimeType(extension: string): string {
  const mimeTypes: Record<string, string> = {
    ".woff2": "font/woff2",
    ".woff": "font/woff",
    ".ttf": "font/ttf",
    ".otf": "font/otf",
  };

  return mimeTypes[extension.toLowerCase()] || "font/woff2";
}

/**
 * Generate font stack with fallbacks
 */
export function generateFontStack(primaryFont: string): string {
  const fallbacks = ["Tahoma", "Arial", "sans-serif"];

  return `'${primaryFont}', ${fallbacks.join(", ")}`;
}

/**
 * Escape CSS string
 */
export function escapeCSSString(str: string): string {
  return str.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}
